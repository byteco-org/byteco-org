(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{"l76/":function(e,n,r){"use strict";r.r(n),r.d(n,"_frontmatter",(function(){return s})),r.d(n,"default",(function(){return d}));r("rzGZ"),r("Dq+y"),r("8npG"),r("Ggvi"),r("E5k/"),r("q1tI");var t=r("7ljp"),o=r("02lv");var s={},i={_frontmatter:s},a=o.a;function d(e){var n=e.components,r=function(e,n){if(null==e)return{};var r,t,o={},s=Object.keys(e);for(t=0;t<s.length;t++)r=s[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,["components"]);return Object(t.b)(a,Object.assign({},i,r,{components:n,mdxType:"MDXLayout"}),Object(t.b)("p",null,"Below is an exhaustive list of all the external types used in the SDK."),Object(t.b)("pre",null,Object(t.b)("code",Object.assign({parentName:"pre"},{className:"language-typescript"}),"import BigNumber from 'bignumber.js'\nimport { ethers } from 'ethers'\n\nimport { SUPPORTED_CHAIN_ID, TRADE_TYPE, TRADE_EXACT, FIXED_UNDERFLOW_BEHAVIOR } from './constants'\n\nexport type BigNumberish = BigNumber | ethers.utils.BigNumber | string | number\n\n//// types for on-chain, submitted, and normalized data\nexport type ChainIdOrProvider = SUPPORTED_CHAIN_ID | ethers.providers.AsyncSendable | ethers.providers.Provider\n\n// type guard for ChainIdOrProvider\nexport function isChainId(chainIdOrProvider: ChainIdOrProvider): chainIdOrProvider is SUPPORTED_CHAIN_ID {\n  const chainId: SUPPORTED_CHAIN_ID = chainIdOrProvider as SUPPORTED_CHAIN_ID\n  return typeof chainId === 'number'\n}\n\n// type guard for ChainIdOrProvider\nexport function isLowLevelProvider(\n  chainIdOrProvider: ChainIdOrProvider\n): chainIdOrProvider is ethers.providers.AsyncSendable {\n  if (isChainId(chainIdOrProvider)) {\n    return false\n  } else {\n    const provider: ethers.providers.AsyncSendable = chainIdOrProvider as ethers.providers.AsyncSendable\n    return 'send' in provider || 'sendAsync' in provider\n  }\n}\n\nexport interface Token {\n  chainId?: SUPPORTED_CHAIN_ID\n  address?: string\n  decimals: number\n}\n\nexport interface TokenAmount {\n  token: Token\n  amount: BigNumberish\n}\n\nexport interface TokenAmountNormalized {\n  token: Token\n  amount: BigNumber\n}\n\nexport interface TokenReserves {\n  token: Token\n  exchange?: Token\n  ethReserve: TokenAmount\n  tokenReserve: TokenAmount\n}\n\nexport interface TokenReservesNormalized {\n  token: Token\n  exchange?: Token\n  ethReserve: TokenAmountNormalized\n  tokenReserve: TokenAmountNormalized\n}\n\nexport interface EthReserves {\n  token: Token\n}\n\n// type for input data\nexport type OptionalReserves = TokenReserves | EthReserves | undefined\n\n// type guard for OptionalReserves\nexport function areTokenReserves(reserves: OptionalReserves): reserves is TokenReserves {\n  const tokenReserves: TokenReserves = reserves as TokenReserves\n  return (\n    tokenReserves !== undefined && tokenReserves.ethReserve !== undefined && tokenReserves.tokenReserve !== undefined\n  )\n}\n\n// type guard for OptionalReserves\nexport function areETHReserves(reserves: OptionalReserves): reserves is EthReserves {\n  const tokenReserves: TokenReserves = reserves as TokenReserves\n  return (\n    tokenReserves !== undefined && tokenReserves.ethReserve === undefined && tokenReserves.tokenReserve === undefined\n  )\n}\n\n// type for output data\nexport type NormalizedReserves = TokenReservesNormalized | EthReserves\n\n// type guard for NormalizedReserves\nexport function areTokenReservesNormalized(reserves: NormalizedReserves): reserves is TokenReservesNormalized {\n  const tokenReservesNormalized: TokenReservesNormalized = reserves as TokenReservesNormalized\n  return tokenReservesNormalized.ethReserve !== undefined && tokenReservesNormalized.tokenReserve !== undefined\n}\n\n//// types for computed data\nexport interface Rate {\n  rate: BigNumber\n  rateInverted: BigNumber\n}\nexport interface MarketDetails {\n  tradeType: TRADE_TYPE\n  inputReserves: NormalizedReserves\n  outputReserves: NormalizedReserves\n  marketRate: Rate\n}\n\nexport interface TradeDetails {\n  marketDetailsPre: MarketDetails\n  marketDetailsPost: MarketDetails\n  tradeType: TRADE_TYPE\n  tradeExact: TRADE_EXACT\n  inputAmount: TokenAmountNormalized\n  outputAmount: TokenAmountNormalized\n  executionRate: Rate\n  marketRateSlippage: BigNumber\n  executionRateSlippage: BigNumber\n}\n\nexport type MethodArgument = BigNumber | number | string\n\nexport interface ExecutionDetails {\n  exchangeAddress: string\n  methodName: string\n  methodId: string\n  value: BigNumber\n  methodArguments: MethodArgument[]\n}\n\n//// types for formatting data\nexport type FlexibleFormat = BigNumber.Format | boolean\n\n// type guard for FlexibleFormat\nexport function isFormat(flexibleFormat: FlexibleFormat): flexibleFormat is BigNumber.Format {\n  const format: BigNumber.Format = flexibleFormat as BigNumber.Format\n  return typeof format !== 'boolean'\n}\n\nexport interface FormatSignificantOptions {\n  significantDigits: number\n  roundingMode: BigNumber.RoundingMode\n  forceIntegerSignificance: boolean\n  format: FlexibleFormat\n}\n\nexport interface FormatFixedOptions {\n  decimalPlaces: number\n  roundingMode: BigNumber.RoundingMode\n  dropTrailingZeros: boolean\n  underflowBehavior: FIXED_UNDERFLOW_BEHAVIOR\n  format: FlexibleFormat\n}\n")))}d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-pages-docs-v-1-02-local-environment-08-types-md-78bd84b4b4d0396896de.js.map