{"version":3,"sources":["webpack:///./src/pages/docs/v1/02-local-environment/08-types.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"kRAMO,IAAMA,EAAe,GAOtBC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,iBAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,+FACA,uBAAK,kCAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,s5IA0JTJ,EAAWK,gBAAiB","file":"component---src-pages-docs-v-1-02-local-environment-08-types-md-78bd84b4b4d0396896de.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"C:/Users/Administrator/uniswap-org-master/src/layouts/docs.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p>{`Below is an exhaustive list of all the external types used in the SDK.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import BigNumber from 'bignumber.js'\nimport { ethers } from 'ethers'\n\nimport { SUPPORTED_CHAIN_ID, TRADE_TYPE, TRADE_EXACT, FIXED_UNDERFLOW_BEHAVIOR } from './constants'\n\nexport type BigNumberish = BigNumber | ethers.utils.BigNumber | string | number\n\n//// types for on-chain, submitted, and normalized data\nexport type ChainIdOrProvider = SUPPORTED_CHAIN_ID | ethers.providers.AsyncSendable | ethers.providers.Provider\n\n// type guard for ChainIdOrProvider\nexport function isChainId(chainIdOrProvider: ChainIdOrProvider): chainIdOrProvider is SUPPORTED_CHAIN_ID {\n  const chainId: SUPPORTED_CHAIN_ID = chainIdOrProvider as SUPPORTED_CHAIN_ID\n  return typeof chainId === 'number'\n}\n\n// type guard for ChainIdOrProvider\nexport function isLowLevelProvider(\n  chainIdOrProvider: ChainIdOrProvider\n): chainIdOrProvider is ethers.providers.AsyncSendable {\n  if (isChainId(chainIdOrProvider)) {\n    return false\n  } else {\n    const provider: ethers.providers.AsyncSendable = chainIdOrProvider as ethers.providers.AsyncSendable\n    return 'send' in provider || 'sendAsync' in provider\n  }\n}\n\nexport interface Token {\n  chainId?: SUPPORTED_CHAIN_ID\n  address?: string\n  decimals: number\n}\n\nexport interface TokenAmount {\n  token: Token\n  amount: BigNumberish\n}\n\nexport interface TokenAmountNormalized {\n  token: Token\n  amount: BigNumber\n}\n\nexport interface TokenReserves {\n  token: Token\n  exchange?: Token\n  ethReserve: TokenAmount\n  tokenReserve: TokenAmount\n}\n\nexport interface TokenReservesNormalized {\n  token: Token\n  exchange?: Token\n  ethReserve: TokenAmountNormalized\n  tokenReserve: TokenAmountNormalized\n}\n\nexport interface EthReserves {\n  token: Token\n}\n\n// type for input data\nexport type OptionalReserves = TokenReserves | EthReserves | undefined\n\n// type guard for OptionalReserves\nexport function areTokenReserves(reserves: OptionalReserves): reserves is TokenReserves {\n  const tokenReserves: TokenReserves = reserves as TokenReserves\n  return (\n    tokenReserves !== undefined && tokenReserves.ethReserve !== undefined && tokenReserves.tokenReserve !== undefined\n  )\n}\n\n// type guard for OptionalReserves\nexport function areETHReserves(reserves: OptionalReserves): reserves is EthReserves {\n  const tokenReserves: TokenReserves = reserves as TokenReserves\n  return (\n    tokenReserves !== undefined && tokenReserves.ethReserve === undefined && tokenReserves.tokenReserve === undefined\n  )\n}\n\n// type for output data\nexport type NormalizedReserves = TokenReservesNormalized | EthReserves\n\n// type guard for NormalizedReserves\nexport function areTokenReservesNormalized(reserves: NormalizedReserves): reserves is TokenReservesNormalized {\n  const tokenReservesNormalized: TokenReservesNormalized = reserves as TokenReservesNormalized\n  return tokenReservesNormalized.ethReserve !== undefined && tokenReservesNormalized.tokenReserve !== undefined\n}\n\n//// types for computed data\nexport interface Rate {\n  rate: BigNumber\n  rateInverted: BigNumber\n}\nexport interface MarketDetails {\n  tradeType: TRADE_TYPE\n  inputReserves: NormalizedReserves\n  outputReserves: NormalizedReserves\n  marketRate: Rate\n}\n\nexport interface TradeDetails {\n  marketDetailsPre: MarketDetails\n  marketDetailsPost: MarketDetails\n  tradeType: TRADE_TYPE\n  tradeExact: TRADE_EXACT\n  inputAmount: TokenAmountNormalized\n  outputAmount: TokenAmountNormalized\n  executionRate: Rate\n  marketRateSlippage: BigNumber\n  executionRateSlippage: BigNumber\n}\n\nexport type MethodArgument = BigNumber | number | string\n\nexport interface ExecutionDetails {\n  exchangeAddress: string\n  methodName: string\n  methodId: string\n  value: BigNumber\n  methodArguments: MethodArgument[]\n}\n\n//// types for formatting data\nexport type FlexibleFormat = BigNumber.Format | boolean\n\n// type guard for FlexibleFormat\nexport function isFormat(flexibleFormat: FlexibleFormat): flexibleFormat is BigNumber.Format {\n  const format: BigNumber.Format = flexibleFormat as BigNumber.Format\n  return typeof format !== 'boolean'\n}\n\nexport interface FormatSignificantOptions {\n  significantDigits: number\n  roundingMode: BigNumber.RoundingMode\n  forceIntegerSignificance: boolean\n  format: FlexibleFormat\n}\n\nexport interface FormatFixedOptions {\n  decimalPlaces: number\n  roundingMode: BigNumber.RoundingMode\n  dropTrailingZeros: boolean\n  underflowBehavior: FIXED_UNDERFLOW_BEHAVIOR\n  format: FlexibleFormat\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}